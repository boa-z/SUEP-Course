# SoC系统设计

1. [[第1章 SoC设计绪论]]
   [[1.1 微电子技术概述]]
       1.1.1 集成电路的发展
       1.1.2 集成电路产业分工
         1. 以生产为导向的初级阶段
         2. 代工厂与设计公司的崛起
         3. “四业分离”的IC产业
   1.2 SoC概述
       1.2.1 什么是SoC
       1.2.2 SoC的优势
         1. 可以实现更为复杂的系统
         2. 具有较低的设计成本
         3. 具有更高的可靠性
         4. 缩短产品设计时间
         5. 减少产品设计返工的次数
         6. 可以满足更小尺寸的设计要求
         7. 可达到低功耗的设计要求
   [[1.3 SoC设计的发展趋势及面临的挑战]]
       1.3.1 SoC设计技术的发展与挑战
         1. 集成密度（复杂性）
            1. 硅器件的复杂性
                1. 对于器件而言，无法确定各个参数理想的缩小比例（包括电源电压、阈值电压等） 
                2. 尺寸缩小使得寄生电容、电感的影响无法忽略，对于制造工艺的可靠性造成一定的影响
            2.设计的复杂性
                1. 芯片验证更为复杂
                2. 芯片测试更为复杂
                3. 混合电路设计更为复杂
         2. 时序收敛
         3. 信号完整性
         4. 低功耗设计
             1. 功耗增加引起的IC运行温度上升会引起半导体电路的运行参数漂移，影响IC的正常工作，及降低电路的可靠性和性能
             2. 功耗增加引起的IC运行温度上升会缩短芯片寿命，并且对系统冷却的要求也相应提高，不仅增加了系统成本，而且限制了系统性能的进一步提高，尤其对于现在流行的移动计算
             3. 为了进行低功耗设计，需要选择不同性能参数的器件，如堕阈值电压的MOS管、不同电源电压的器件等，这样一来就大大增加了设计复杂度
         5. 可制造性设计及成品率
       1.3.2 SoC设计方法的发展与挑战
         1. IP复用将不仅仅在硬件领域，在软件设计领域同样需要
         2. 今后的设计将在一个应用平台上完成，该平台将包括一个或多个处理器和逻辑单元，即基于平台的设计
         3. 可编程、可配置、可扩展的处理器核的使用，会使得原有的设计流程和设计者思维发生变化
         4. 系统级验证时，利用高级语言搭建验证平台和编写验证向量，需要相应的工具支持
         5. 软硬件协同综合，使得在同样的约束条件下，系统达到最优的设计性能
       1.3.3 未来的SoC
   本章参考文献

[[2. 第2章 SoC设计流程]]
   [[2.1 软硬件协同设计]]
         [[软硬件协同设计的SoC设计流程]]
     1. 系统需求说明
     2. 高级算法建模与仿真
     3. 软硬件划分过程
     4. 软硬件同步设计
     5. 硬件系统测试
   [[2.2 基于标准单元的SoC芯片设计流程]]
     1. 硬件设计定义说明（Hardware Design Specification）
     2. 模块设计及IP复用（Module Design & IP Reuse）
     3. 顶层模块集成（Top Level Integration）
     4. 前仿真（Pre-layout Simulation）
     5. 逻辑综合（Logic Synthesis）
     6. 版图布局规划（Floorplan）
     7. 电源网络功耗分析（Power Network Analysis）
     8. 单元布局和优化（Placement & Optimization）
     9. 静态时序分析（STA，Static Timing Analysis）
     10. 形式验证（Formal Verification）
     11. 可测性电路插入（DFT，Design for Test）
     12. 时钟树综合（Clock Tree Synthesis）
     13. 布线设计（Routing）
     14. $\color{red}功耗分析$
     15. $\color{red}信号完整性$
     16. $\color{red}优化$
     17. 寄生参数提取（Parasitic Extraction）
     18. 后仿真（Post-layout Simulation）
     19. ECO修改（ECO，Engineering Change Order）
     20. 物理验证（Physical Verification）
     21. 交付芯片制造厂（Tape Out）
   [[2.3 基于FPGA的SoC设计流程]]
       2.3.1 FPGA的结构
         1. 典型FPGA内部结构
             1. 可编程逻辑块（CLB，Configurable Logic Blocks）
             2. 可编程输入/输出但愿（IOB）
             3. 数字时钟管理模块（DCM）
                 1. 实现零时钟偏移（Skew），消除时钟分配延迟，并实现时钟闭环控制
                 2. 时钟可以映射到PCB上，用于同步外部时钟，减少对外部芯片的要求，对芯片内、外的时钟进行一体化控制，利于系统设计
             4. 嵌入式块RAM（BRAM）
             5. 内嵌专用IP单元
         2. SoC FPGA结构
       2.3.2 基于FPGA的设计流程
         [[1. 典型的FPGA设计流程]]
             1. 电路功能设计
             2. 设计输入
             3. 功能仿真
             4. 综合
             5. 综合后仿真
             6. 实现与布局布线
             7. 时序仿真与验证
             8. 板级仿真与验证
             9. 芯片编程与调试
         [[2. 面向SoC的FPGA设计流程（基于Xilinx EDK进行面向SoC的FPGA设计流程）]]
         [[3. 面向高层次综合的FPGA设计流程（以Xilinx为例）]]
   本章参考文献

 3. 第3章 SoC设计与EDA工具
    [[3.1 电子系统级设计与工具]]
    [[3.2 验证的分类及相关工具]]
         1. 验证原始描述的正确性
         2. 验证设计的逻辑功能是否符合设计规范的要求
         3. 验证设计结果的时序是否符合原始设计规范的性能指标
         4. 验证结果是否包含违反物理设计规则的错误
       3.2.1 验证方法的分类
         1. 动态验证
         2. 静态验证
       3.2.2 动态验证及相关工具
         1. 电路级仿真工具
             1. SPICE
             2. NanoSim
         2. 逻辑仿真工具
             1. 基于事件的仿真器
             2. 基于周期的仿真器
                 1. VCS
                 2. ModelSim
       3.2.3 静态验证及相关工具
         1. 形式验证工具
         2. 静态时序分析工具
    3.3 逻辑综合及综合工具
       3.3.1 EDA工具的综合流程
       3.3.2 EDA工具的综合策略
         1. 以速度为目标的综合策略
         2. 成本尽可能低的综合策略
         3. 速度和成本折中的综合策略
       3.3.3 优化策略
         1. 器件复用
         2. 时序重排
         3. 状态机重新编译
       3.3.4 常用的逻辑综合工具
    [[3.4 可测性设计与工具]]
       3.4.1 测试和验证的区别
       3.4.2 常用的可测性设计
         1. 内部扫描测试设计
         2. 自动测试向量生成（ATPG，Automation Test Patterm Generation）
         3. 存储器内建自测试（Memory Built-in-self-test）
         4. 边界扫描测试（Boundary Scan）
    3.5 布局布线与工具
       3.5.1 EDA工具的布局布线流程
         1. 布局规划（Floorplan）
         2. 布局、器件放置（Placement）
         3. 时钟树综合（Clock Tree Synthesis）
         4. 布线（Routing）
       3.5.2 布局布线工具的发展趋势
    3.6 物理验证及参数提取与相关的工具
       3.6.1 物理验证的分类
         1. 设计规则检查（DRC，Design Rule Check）
         2. 电气规则检查（ERC，Electronic Rule Check）
         3. 版图电路图同一性比较（LVS，Layout Versus Schematic）
       3.6.2 参数提取
         1. 1-D提取
         2. 2-D提取
         3. 3-D提取
    3.7 著名EDA公司与工具介绍
    3.8 EDA工具的发展趋势
     1. 支持软硬件协同设计的ESL工具
     2. 支持良率设计的DFM工具
     3. 提高EDA工具本身的性能
   本章参考文献

[[4. 第4章 SoC系统架构设计]]
   [[4.1 SoC系统架构设计的总体目标与阶段]]
       4.1.1 功能设计阶段
       4.1.2 应用驱动的系统架构设计阶段
       4.1.3 基于平台的系统架构设计阶段
   [[4.2 SoC中常用的处理器]]
       4.2.1 通用处理器
         1. ARM系列处理器
         2. MIPS系列处理器
         3. PowerPC系列处理器
         4. RISC-V系列处理器
       [[4.2.2 处理器的选择]]
   [[4.3 SoC中常用的总线]]
       4.3.1 AMBA总线
       4.3.2 CoreConnect总线
       4.3.3 Wishbone总线
       [[4.3.4 开放核协议（OCP）]]
       4.3.5 复杂的片上总线架构
   [[4.4 SoC中典型的存储器]]
       4.4.1 存储器分类
        1. 按照存储介质分类
        2. 按照存储方式分类
        3. 按信息是否可更改分类
        4. 按照断电后信息的可保存性分类
       4.4.2 常用的存储器
         1. 静态随机存储器SRAM
         2. 动态随机存储器DRAM
         3. 闪存Flash
       [[4.4.3 新型存储器]]
   [[4.5 多核SoC的系统架构设计]]
       4.5.1 可用的并发性
       4.5.2 多核SoC设计中的系统架构选择
         1. 处理器与存储器架构
         2. 核间通信与Cache的架构
         3. 操作系统的设计
         4. 提高并行性
       4.5.3 多核SoC的性能评价
         1. 阿姆达定律
         2. 古斯塔夫森定律
       [[4.5.4 几种典型的多核SoC系统架构]]
         1. 片上网络
         2. 通用处理器和DSP结合的异构多核架构
   [[4.6 SoC中的软件架构]]
         1. 数据流的路径
         2. 软件环境
         3. 软硬件接口
         4. 存储空间映射
         5. 设备驱动
         6. 初始化、复位、Bootloader程序
         7. 中断服务程序及中断向量
         8. I/O引脚的复用
         9. 模型
   [[4.7 电子系统级（ESL）设计]]
       4.7.1 ESL发展的背景
       4.7.2 ESL设计基本概念
       4.7.3 ESL协同设计的流程
       4.7.4 ESL设计的特点
         1. 更早地进行软件开发
         2. 更高层次上的硬件设计
         3. 设计的可配置性和自动生成
         4. 方便的架构设计
         5. 快速测试和验证
       [[4.7.5 ESL设计的核心—事务级建模]]
         1. 事务级建模介绍
         2. 事务级建模的一般理论
         3. 事务级建模标准
       4.7.6 事务级建模语言简介及设计实例
         1. 实例一：没有时钟的DMA模型
         2. 实列二：周期精确的DMA模型
       4.7.7 ESL设计的挑战
         1. 如何设计电子系统级IP
         2. 如何定义ESL的抽象层次
         3. 如何提出相应的设计方法学
         4. 如何转变设计人员的观念
   本章参考文献

5. 第5章 IP复用的设计方法
   [[5.1 IP的基本概念和IP分类]]
     1. IP的定义
     2. IP的分类
         1. 依设计流程区分
             1. 软核IP（Soft IP）
             2. 固核IP（Firm IP）
             3. 硬核IP（Hard IP）
         2. 依差异化程度来区分
             1. 基础IP（Foundation IP）
             2. 标准IP（Standard IP）
             3. 明星IP（Star IP或Unique IP）
   [[5.2 IP设计流程]]
       5.2.1 设计目标
          1.  可配置，参数化，提供最大程度的灵活性
          2. 标准接口
          3. 多种工艺下的可用性，提供各种库的综合脚本，可以移植到新的技术
          4. 完全、充分的验证，保证设计的健壮性/鲁棒性？
          5. 完整的文档资料
       5.2.2 设计流程
          1. 定义关键特性
          2. 规划和制定设计规范
             1. 功能设计规范
             2. 验证规范
             3. 封装规范
             4. 开发计划
          3. 模块设计和集成
             1. 设计流程
             2. 硬核的模型建立
                 1. 功能模型（Functional Model）
                 2. 时序模型（Timing Model）
                 3. 功耗模型（Power Model）
                 4. 测试模型（Test Model）
                 5. 物理模型（Physical Model）
          4. IP产品化
   5.3 IP的验证
     1. IP验证计划
         1. 验证策略的描述
         2. 仿真环境的详细描述，包括模块连接关系图
         3. 验证平台部件清单，例如总线功能模型和总线监控器，对于每一个模块，都应该有对应的关键功能说明，还必须说明对应的模块是公司已经拥有，还是可以通过第三方购买，或者需要自行设计
         4. 验证工具的清单还包括仿真器和验证平台自动产生工具
         5. 特定验证向量清单，包括每一个特定测试的测试目的和规模大小，规模大小将有助于估计生成对应验证向量所需要的代价
         6. IP关键特性的分析报告，并且说明对应这些关键特性可以用哪些测试向量进行测试验证
         7. IP中哪些功能可以在子模块级进行测试验证，哪些必须在IP级进行测试验证的说明
         8. 每一个子模块核和顶层IP测试覆盖率的说明
         9. 用来说明验证要达到的标准的规范
     2. IP验证策略
         1. 兼容性验证
         2. 边界验证
         3. 随机验证
         4. 应用程序验证
         5. 回归验证
    3. 验证平台的设计
         1. 以事务处理的方式产生测试激励，检查测试响应
         2. 验证平台应该尽可能地使用可复用仿真模块，而不是从头开始编写
         3. 所有的响应检查应该是自动的，而不是设计人员通过观看仿真波形的方式来判断结果是否正确
   5.4 IP的选择
    1. IP种类的选择
    2. 产品完整性
   5.5 IP交易模式
    1. IP收费结构
         1. 授权费（License）
         2. 权利金（Royalty）
         3. 其他收入
    2. 授权模式的演变
   5.6 IP复用技术面临的挑战
    1. 可复用性和多IP集成
    2. 复杂冗长的验证和仿真时间
    3. 来自商务模式的挑战
   5.7 IP标准组织
   5.8 基于平台的SoC设计方法
       5.8.1 平台的组成与分类
         1. 平台的组成
             1. 硬件：主要包括处理器、存储器、通信总线及I/O单元等
             2. 软件：主要包括操作系统、功能驱动和应用程序等
             3. 体系结构的详细规范：主要包括总线结构、时钟及各个IP的约束条件
             4. 验证过的逻辑和物理综合脚本
             5. 软硬件系统验证环境和基本验证模型
             6. 各模块的设计说明
         2. 平台的分类
             1. 全应用平台
             2. 以处理器为中心的平台
             3. 以通信为中心的平台
             4. 完全可编程平台
       5.8.2 基于平台的SoC设计流程与特点
         1. 流程
             1. 基于市场目标，决定该平台主要的应用领域
             2. 选择主要的软硬件IP模块、总线架构
             3. 确定系统的架构和模块间的通信方式
             4. 选择或开发必要的软硬件设计工具
             5. 选择或开发所需的验证组件，进行平台体系的验证
             6. 模块的集成方法及系统级验证环境的设计
         2. 特点
             1. 平台设计有很强的可配置性，但却不能改变，如果设计中包含一个不用的模块，可以通过设置是这个模块不工作，而不是将他从设计中拿走
             2. 平台设计使用的是标准的接口，这样就使得采用相同标准接口的辅助IP模块的集成变得很简单
             3. 能够支持应用软件的开发
             4. 架构相对稳定，易于进行系统级的验证
             5. 能够对速度、成本、功耗等性能指标进行验证与评估
       5.8.3 基于平台的设计实例
本章参考文献

6. 第6章 RTL代码编写指南
   [[6.1 编写RTL代码之前的准备]]
         1. 是否与设计团队共同讨论过设计中将会发生的关键问题
         2. 是否已准备好设计文档
         3. 设计文档中总线是如何定义的
         4. 设计文档中是否定义了设计的划分方法
         5. 设计中的时钟是怎样考虑的
         6. 对I/O是否有特殊需求
         7. 是否需要其他IP，这些IP的封装（Package）是否完整的包括了每一步设计所需的文件
         8. 是否考虑了IP复用设计
         9. 是否考虑了可测性设计
         10. 整个设计的面积是引脚限制（Pin-limited）还是门数限制（Gate-limited）
         11. 设计的运行速度是否能超过工艺速度极限
         12. 时序和后端设计是否有特殊的需求
       6.1.1 与团队共同讨论设计中的问题
       6.1.2 根据芯片架构准备设计说明书
         1. 模块功能的简要介绍
         2. 顶层模块的接口信号
         3. 所有控制寄存器地址及功能描述
         4. 顶层模块的主要结构图
         5. 子模块功能
         6. 子模块的接口信号
         7. 子模块的主要结构图
         8. 子模块的实现原理
         9. 时钟信号的连接（如Multicycle Path、False Path、Negedge Clock、Generated Clock）
         10. 复位信号的连接（如Gated Reset、Soft Reset）
       6.1.3 总线设计的考虑
         1. 使设计可视性更强
         2. 没有无效的时序路径
         3. 简化的综合约束
         4. 简化可测性设计的实现
         5. 简化总线控制逻辑设计
       6.1.4 模块的划分
         1. 关于芯片级的模块划分
         2. 关于核心逻辑的模块划分
         3. 把多周期路径或伪路径限制到一个模块中
         4. 根据时钟的相关性划分模块
       6.1.5 对时钟的处理
       6.1.6 IP的选择及设计复用的考虑
         1. 在系统架构设计做好模块划分时，必须确定哪些模块基于标准单元库进行设计，哪些模块需要购买IP，IP模块的对接需要增加哪些连接性设计
             1. 时钟生成应该被划分为单独的模块，如分频电路、计数器、多路时钟信号选择器等，以便于其他设计人员设置约束
             2. 总线接口逻辑应被划分为单独的模块，如总线接口、地址译码器，当该模块被用于不同设计中时，总线及寄存器的地址很可能会改变
             3. 提供特殊测试功能的逻辑应该被划分为单独的模块，这些功能逻辑可能会根据以后的测试策略而改变
             4. 对于功能模块的设计采用必要的层次化描述，便于该模块的设计者了解该设计
         2. 模块间的接口协议要尽可能的简单，模块间的接口定义要尽可能与国际上通用的接口协议完全一致。
         3. 要注意积累IP和IP集成的经验。
         4. 如果是对硬核IP的集成，还必须在时钟分布、关键路径的布线、电源和地线的布线、IP模块支持的测试结构等方面进行考虑，与系统芯片保持一致。
       6.1.7 对可测性的考虑
         1. 复位信号在测试过程中应该被设置为无效，否则测试过程可能被复位信号打乱
         2. 门控时钟在测试中应当有效
         3. 三态的驱动在测试中必须有可知的输出
         4. 边界扫描（Boundary Scan）问题
         5. RAM的测试考虑
         6. 测试控制考虑
       6.1.8 对芯片速度的考虑
       6.1.9 对布线的考虑
   [[6.2 可综合RTL代码编写指南]]
       6.2.1 可综合RTL代码的编写准则
         1. 命名
             1. 模块的命名
                 1. 在系统设计阶段应该为每个模块进行命名，最终的顶层模块应该以芯片的名称来命名
                 2. 在顶层模块中，除I/O引脚和不需要综合的模块外，其余作为次级顶层模块，建议以xx_core.v命名
                 3. 对于多处理器的设计，共享模块以（模块名_处理器名）命名
                 4. 如果例化一个模块，则例化名最好与模块名相同；如果需要例化很多模块，则用下标来区分
                 5. 模块的命名和该模块的功能相结合，如Arithmetic Logical Unit模块，可以命名为ALU
             2. 信号的命名
                 1. 所有信号的命名由小写字母、下画线符号和数字组成，并且以小写字母开头，因为以下画线符号开头的字母可能与某些工具相冲突
                 2. 低电平有效的信号后一律加下画线和字母n或b，如sysrst_n、fifofull_b
                 3. 总线由高位到低位命名，如bus\[31:0\]
                 4. 不需要在信号名字中表明信号的方向，如用my_signal比my_signal_in更简明
                 5. 命名应当尽量保持一致性，一些全局的信号（clock，reset）在每个子模块中都有相同的名字，两个子模块的接口信号也应当一致。在信号列表中，以注释形式指明信号的方向
                 6. 在模块的例化过程中采用信号名称连形式（connection by name），避免使用指明位置的形式，并且每行例化一个信号
                 7. 在信号列表中，将clk、reset等扇出比较大的信号列在最后，统一规范，便于阅读
                 8. 命名要尽量显得有意义，说明它的用途、目的、功能等
             3. 同步触发器的命名
             4. 时钟信号的命名
                 1. 全局时钟以clk命名
                 2. 其他时钟信号的命名需要包含相关的频率信息，如clk_32k
             5. 文件的命名
         2. 编码风格
             1. 利用缩进来显示代码的逻辑结构，缩进一致，并以Tab为单位
             2. 对于时序单元必须采用非阻塞赋值
             3. 组合逻辑采用阻塞赋值
             4. 不要将阻塞赋值和非阻塞赋值混合在一个程序块中
             5. 保证敏感列表的完整，避免仿真和综合过程中出现功能错误
             6. 尽量不使用循环结构
             7. 对代码加上适当的注释
             8. 对于多行的注释，使用/\*\*/进行注释
         3. 综合考虑
             1. 每个模块尽可能只使用一个主时钟
             2. 复位信号以“reset”命名，表示高电平有效，如果低电平有效则命名为“reset_b”。通常复位信号为异步信号
             3. 模块的分割最好能够使得在模块内部的输入和输出端直接和触发器相连接，这样在综合的过程中，时序约束的设置将非常方便
             4. 不在数据通路上的触发器都需要有复位信号
             5. 数据通路上触发器的复位信号根据流水线的划分来设置
             6. 如果电路中同时存在具备复位信号的触发器和不具备复位信号的触发器，不要将它们放在一个程序块中
             7. 在case语句中，指明所有可能出现的情况，如果不需要所有情况，加上default语句
             8. 代码的描述应该尽量简单，如果在编码过程无法预计其最终的综合结果，那综合工具可能会花很长的时间去综合
             9. 尽量保证每个模块的简练和易读性，如果模块太大时可以考虑将其划分为几个子模块
             10. 在内部逻辑中避免使用三态逻辑
             11. 不要在代码描述中加入specify语句去规定多周期路径，这样会使综合变得很慢，并且增加静态时序分析的难度
             12. 避免触发器在综合过程中生成锁存器，在if else语句中，如果设计没有很好地覆盖到各种情况，就很有可能综合产生一些锁存器的结构
             13. 尽量避免异步逻辑、带有反馈环的组合电路及自同步逻辑
             14. 尽量把需要综合的代码置于节点模块，层次化模块仅起到连接节点模块的作用
             15. 输入和输出信号在声明的时候默认为wire类型，因此不必要在代码中重复声明
             16. 避免不必要的函数调用，重复的函数调用会增加综合次数，不仅造成电路面积的浪费，还会使综合时间变长
             17. 通常在Verilog语言中，有always和initial两个程序块，synopsys的综合工具忽略initial程序块，并将产生警告
             18. 在综合过程中，工具将忽略电路中的延时语句
       6.2.2 利用综合进行代码质量检查
         1. 在综合的log file中，可能有出错的警告。他们很可能是真正的错误或不理想的结果。如果是的话，应该修改RTL
         2. 在综合的log file中，除了会报出RTL问题，还会报出约束条件是否存在的问题，如忘记定义分频器输出的时钟等。如果必要的话，应该修改综合用的约束条件
         3. 在时序分析报告中，哪里是设计的关键路径？它们是设计者所想得到的吗？不满足时序要求的原因明显吗？能通过简单修改代码就解决吗？能隔离这条路径或者它是一大堆逻辑中的一部分吗？负裕量（Negative Slack）有多大？如果大于时钟周期的50%将是大问题，小于时钟周期的25%可能在后端设计时可以修复
         4. 在设计中有多少路径违反了时序约束，违反了多少，这是对结果质量的度量，也是对“还有多少工作要做”的度量
         5. 这些违反时序的路径是否是公用起始点或终止点
         6. 查看关键路径里包含多少级逻辑单元
   6.3 调用Synopsys DesignWare来优化设计
   本章参考文献

7. 第7章 同步电路设计及其与异步信号交互的问题
   [[7.1 同步电路设计]]
       7.1.1 同步电路的定义
       7.1.2 同步电路的时序收敛问题
       7.1.3 同步电路设计的优点与缺陷
         1. 同步电路设计的优点
             1. 在同步设计中，EDA工具可以保证电路系统的时序收敛，有效避免了电路设计中出现竞争冒险现象
             2. 由于触发器只有在时钟边沿才改变取值，很大限度地减小了整个电路受毛刺和噪声影响的可能
         2. 同步电路设计的缺陷
   7.2 全异步电路设计
       7.2.1 异步电路设计的基本原理
         1. 自定时方法
         2. 握手协议
       7.2.2 异步电路设计的优点与缺点
         1. 模块化特性突出
         2. 对信号的延迟不敏感
         3. 没有时钟偏斜问题
         4. 有潜在的高性能特性
         5. 好的电磁兼容性
         6. 具有低功耗特性
   7.3 异步信号与同步电路交互的问题及其解决方法
       7.3.1 亚稳态
         1. 亚稳态现象
         2. 亚稳态问题的解决及其RTL实现
       7.3.2 异步控制信号的同步及其RTL实现
         1. 快时钟同步慢时钟域下的异步控制信号
         2. 慢时钟同步快时钟域下的异步控制信号
             1. 握手机制实现方法一
             2. 握手机制实现方法二
       7.3.3 异步时钟域的数据同步及其RTL实现
         1. 握手机制
         2. 先入先出队列（FIFO）
             1. FIFO的结构与原理
                 1. 待同步的数据时钟域会在其写信号的控制之下，将数据写入到FIFO中
                 2. 目的时钟域在发现空标志位无效后，执行FIFO读动作，读出被异步时钟域写入FIFO的数据
                 3. 如果只要同步一个数据，空标志位再次有效
                 4. 如果需要同步多个数据，因为FIFO的读/写之间可以不受影响地进行，所以待同步地数据时钟会一直写FIFO，直到所有的需要同步的数据已经写完，并且目的时钟域根据空标志位来判断是否还有异步数据没有被同步，直到空标志位再次有效说明这次同步完成
             2. FIFO设计中的亚稳态问题
                 1. 以格雷码编码表示读/写指针，用格雷码加法器来实现读/写地址的加一动作
                 2. 用同步器将读指针同步到FIFO满标志的产生逻辑，同样用同步器将写指针同步到FIFO空标志的产生逻辑中
   7.4 SoC设计中的时钟规划策略
    1. 需要强调的是：
         1. 亚稳态现象在异步电路设计中并没有完美的解决方案，不可能避免亚稳态的出现
         2. 通过同步器，在空间上可以把亚稳态现象控制在电路的一个很小的区域，在时间上可以把亚稳态的出现时间控制到最小
         3. 在电路上，无论是异步控制信号的同步还是数据的同步，两者不可能完全无关，异步数据的同步需要异步控制信号的同步，异步控制信号的同步正是为了异步数据的同步
    2. 尽可能使用同步设计
         1. 对于同步电路，逻辑综合和时钟树综合等EDA工具能够发挥更大的作用，可以用静态时序分析工具来分析单时钟同步设计的时序收敛问题
         2. 可测性设计（DFT）的插入工作得到最大的简化
    3. 注意同步电路设计的缺陷
         1. 噪声问题，因为所有的时序逻辑单元都会在同一时钟的边沿发生改变，这样会对数字系统造成很大的辐射噪声
         2. 时钟树上的功耗很大
    4. 如果必须采用不同的时钟，则要注意：
         1. 后端设计的复杂化，如约束条件中要考虑多周期路径（Multi Cycle Path）
         2. 可测性设计更加复杂，因为此时系统中需要有多条独立的扫描链
         3. 越多的时钟域，发生亚稳态的概率就会越大
    5. 设计规划中应注意以下几点：
         1. 尽可能将不同时钟域的数量减到越少越好
         2. 尽可能将异步交互电路归入同一或多个独立的模块，这样不但方便后端设计脚本的书写，也方便代码的阅读
         3. 尽可能避免使用电平触发器（Latch），因为静态时序分析会变得复杂，不能得到EDA工具很好的支持
         4. 尽可能减少时钟树的延时，因为这个延时可能会造成系统功能失效和多余的功耗
         5. 任何异步时钟域交互的环节都要尽可能避免亚稳态现象
   本章参考文献

8. 第8章 综合策略与静态时序分析方法
   [[8.1 逻辑综合]]
       8.1.1 流程介绍
       8.1.2 SoC设计中常用的综合策略
   8.2 物理综合的概念
       8.2.1 物理综合的产生背景
       8.2.2 操作模式
   8.3 实例—用Synopsys的工具Design Compiler进行逻辑综合
       8.3.1 指定库文件
       8.3.2 读入设计
       8.3.3 定义工作环境
       8.3.4 设置约束条件
       8.3.5 设定综合优化策略
       8.3.6 设计脚本举例
   [[8.4 静态时序分析]]
       8.4.1 基本概念
       8.4.2 实例—用Synopsys的工具PrimeTime进行时序分析
   8.5 统计静态时序分析
       8.5.1 传统时序分析的局限
       8.5.2 统计静态时序分析的概念
       8.5.3 统计静态时序分析的步骤
   本章参考文献

9. 第9章 SoC功能验证
   [[9.1 功能验证概述]]
       9.1.1 功能验证的概念
       9.1.2 SoC功能验证的挑战
       9.1.3 SoC功能验证的发展趋势
   [[9.2 功能验证方法与验证规划]]
   9.3 系统级功能验证
       9.3.1 系统级的功能验证
       9.3.2 软硬件协同验证
   9.4 仿真验证自动化
       9.4.1 激励的生成
       9.4.2 响应的检查
       9.4.3 覆盖率的检测
   [[9.5 基于断言的验证]]
       9.5.1 断言语言
       9.5.2 基于断言的验证
       9.5.3 断言的其他用途
   9.6 通用验证方法学
   本章参考文献

10. 第10章 可测性设计
    [[10.1 集成电路测试概述]]
        10.1.1 测试的概念和原理
        10.1.2 测试及测试向量的分类
        10.1.3 自动测试设备
    10.2 故障建模及ATPG原理
        10.2.1 故障建模的基本概念
        10.2.2 常见故障模型
        10.2.3 ATPG基本原理
        10.2.4 ATPG的工作原理
        10.2.5 ATPG工具的使用步骤
    10.3 可测性设计基础
        10.3.1 可测性的概念
        10.3.2 可测性设计的优势和不足
    [[10.4 扫描测试（SCAN）]]
        10.4.1 基于故障模型的可测性
        10.4.2 扫描测试的基本概念
        10.4.3 扫描测试原理
        10.4.4 扫描设计规则
        10.4.5 扫描测试的可测性设计流程及相关EDA工具
    [[10.5 存储器的内建自测]]
        10.5.1 存储器测试的必要性
        10.5.2 存储器测试方法
        10.5.3 BIST的基本概念
        10.5.4 存储器的测试算法
        10.5.5 BIST模块在设计中的集成
    10.6 边界扫描测试
        10.6.1 边界扫描测试原理
        10.6.2 IEEE 1149.1标准
        10.6.3 边界扫描测试策略和相关工具
    10.7 其他DFT技术
        10.7.1 微处理器核的可测性设计
        10.7.2 Logic BIST
    10.8 DFT技术在SoC中的应用
        10.8.1 模块级的DFT技术
        10.8.2 SoC中的DFT应用
    本章参考文献

11. 第11章 低功耗设计
    [[11.1 为什么需要低功耗设计]]
    11.2 功耗的类型
    11.3 低功耗设计方法
    [[11.4 低功耗技术]]
        11.4.1 静态低功耗技术
        11.4.2 动态低功耗技术
        11.4.3 采用低功耗技术的设计流程
        [[11.4.4 低功耗SoC系统的动态管理]]
        11.4.5 低功耗SoC设计技术的综合考虑
    11.5 低功耗分析和工具
    11.6 UPF及低功耗设计实现
        11.6.1 基于UPF的低功耗电路综合
        11.6.2 UPF功耗描述文件举例
    11.7 低功耗设计趋势
    本章参考文献

12. 第12章 后端设计
    [[12.1 时钟树综合]]
    12.2 布局规划
    12.3 ECO技术
    12.4 功耗分析
    12.5 信号完整性的考虑
        12.5.1 信号完整性的挑战
        12.5.2 压降和电迁移
        12.5.3 信号完整性问题的预防、分析和修正
    12.6 物理验证
    [[12.7 可制造性设计/面向良率的设计]]
        12.7.1 DFM/DFY的基本概念
        12.7.2 可制造性设计驱动的方法
        12.7.3 分辨率增强技术提高DFM/DFY的方法
        12.7.4 其他DFM/DFY问题及解决方法
        12.7.5 EDA工具对于DFM/DFY技术的支持
    本章参考文献

13. 第13章 SoC中数模混合信号IP的设计与集成
    [[13.1 SoC中的数模混合信号IP]]
    13.2 数模混合信号IP的设计流程
    13.3 基于SoC复用的数模混合信号（AMS）IP包
    13.4 数模混合信号（AMS）IP的设计及集成要点
        13.4.1 接口信号
        13.4.2 模拟与数字部分的整体布局
        13.4.3 电平转换器的设计
        13.4.4 电源的布局与规划
        13.4.5 电源/地线上跳动噪声的消除
    本章参考文献

14. 第14章 I/O环的设计和芯片封装
    [[14.1 I斜杠O单元介绍]]
    14.2 高速I/O的噪声影响
    14.3 静电保护
        14.3.1 ESD的模型及相应的测试方法
        14.3.2 ESD保护电路的设计
    14.4 I/O环的设计
        14.4.1 考虑对芯片的尺寸的影响
        14.4.2 考虑对芯片封装的影响
        14.4.3 考虑对噪声的影响
        14.4.4 考虑对芯片ESD的影响
    [[14.5 SoC芯片封装]]
        14.5.1 芯片封装的功能
        14.5.2 芯片封装的发展趋势
        14.5.3 常见的封装技术
        14.5.4 3D IC技术
        14.5.5 芯片封装的选择
    本章参考文献

